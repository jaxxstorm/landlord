package controller

import (
	"context"
	"fmt"
	"testing"

	"go.uber.org/zap"

	"github.com/google/uuid"
	"github.com/jaxxstorm/landlord/internal/tenant"
	"github.com/jaxxstorm/landlord/internal/workflow"
)

// mockTenantRepository implements tenant.Repository for testing controller
type mockTenantRepository struct {
	getTenantFunc    func(ctx context.Context, tenantID string) (*tenant.Tenant, error)
	updateTenantFunc func(ctx context.Context, t *tenant.Tenant) error
}

func (m *mockTenantRepository) GetTenant(ctx context.Context, tenantID string) (*tenant.Tenant, error) {
	if m.getTenantFunc != nil {
		return m.getTenantFunc(ctx, tenantID)
	}
	return nil, tenant.ErrTenantNotFound
}

func (m *mockTenantRepository) UpdateTenant(ctx context.Context, t *tenant.Tenant) error {
	if m.updateTenantFunc != nil {
		return m.updateTenantFunc(ctx, t)
	}
	return nil
}

func (m *mockTenantRepository) CreateTenant(ctx context.Context, t *tenant.Tenant) error {
	return nil
}

func (m *mockTenantRepository) GetTenantByID(ctx context.Context, id uuid.UUID) (*tenant.Tenant, error) {
	return nil, nil
}

func (m *mockTenantRepository) ListTenants(ctx context.Context, filters tenant.ListFilters) ([]*tenant.Tenant, error) {
	return nil, nil
}

func (m *mockTenantRepository) ListTenantsForReconciliation(ctx context.Context) ([]*tenant.Tenant, error) {
	return nil, nil
}

func (m *mockTenantRepository) RecordStateTransition(ctx context.Context, transition *tenant.StateTransition) error {
	return nil
}

func (m *mockTenantRepository) GetStateHistory(ctx context.Context, tenantID uuid.UUID) ([]*tenant.StateTransition, error) {
	return nil, nil
}

func (m *mockTenantRepository) DeleteTenant(ctx context.Context, id uuid.UUID) error {
	return nil
}

// mockWorkflowClientForController implements WorkflowClient interface for testing
type mockWorkflowClientForController struct {
	triggerFunc           func(ctx context.Context, t *tenant.Tenant, action string) (string, error)
	triggerWithSourceFunc func(ctx context.Context, t *tenant.Tenant, action, source string) (string, error)
	determineActionFunc   func(status tenant.Status) (string, error)
	getStatusFunc         func(ctx context.Context, executionID string) (*workflow.ExecutionStatus, error)
}

func (m *mockWorkflowClientForController) TriggerWorkflow(ctx context.Context, t *tenant.Tenant, action string) (string, error) {
	// Match real implementation: delegate to TriggerWorkflowWithSource with "controller" source
	return m.TriggerWorkflowWithSource(ctx, t, action, "controller")
}

func (m *mockWorkflowClientForController) TriggerWorkflowWithSource(ctx context.Context, t *tenant.Tenant, action, source string) (string, error) {
	if m.triggerWithSourceFunc != nil {
		return m.triggerWithSourceFunc(ctx, t, action, source)
	}
	return "exec-123", nil
}

func (m *mockWorkflowClientForController) DetermineAction(status tenant.Status) (string, error) {
	if m.determineActionFunc != nil {
		return m.determineActionFunc(status)
	}
	return "plan", nil
}

func (m *mockWorkflowClientForController) GetExecutionStatus(ctx context.Context, executionID string) (*workflow.ExecutionStatus, error) {
	if m.getStatusFunc != nil {
		return m.getStatusFunc(ctx, executionID)
	}
	return &workflow.ExecutionStatus{
		ExecutionID: executionID,
		State:       workflow.StateRunning,
	}, nil
}

// TestControllerSkipsActiveWorkflow tests controller skips tenant with active workflow
func TestControllerSkipsActiveWorkflow(t *testing.T) {
	logger, _ := zap.NewDevelopment()

	activeTenant := &tenant.Tenant{
		ID:       uuid.New(),
		TenantID: "test-tenant",
		Status:   tenant.StatusPlanning,
		WorkflowExecutionID: stringPtr("exec-active-123"),
	}

	triggerCount := 0
	wfClient := &mockWorkflowClientForController{
		triggerFunc: func(ctx context.Context, t *tenant.Tenant, action string) (string, error) {
			triggerCount++
			return "exec-new", nil
		},
		getStatusFunc: func(ctx context.Context, executionID string) (*workflow.ExecutionStatus, error) {
			// Return running state - should be skipped
			return &workflow.ExecutionStatus{
				ExecutionID: executionID,
				State:       workflow.StateRunning,
			}, nil
		},
	}

	tenantRepo := &mockTenantRepository{
		getTenantFunc: func(ctx context.Context, tenantID string) (*tenant.Tenant, error) {
			return activeTenant, nil
		},
	}

	reconciler := &Reconciler{
		tenantRepo:     tenantRepo,
		workflowClient: wfClient,
		logger:         logger,
		ctx:            context.Background(),
	}

	err := reconciler.reconcile("test-tenant")
	if err != nil {
		t.Errorf("reconcile should not fail: %v", err)
	}

	// Should not trigger new workflow
	if triggerCount != 0 {
		t.Errorf("expected no trigger for active workflow, got %d triggers", triggerCount)
	}
}

// TestControllerReTriggerAfterCompletion tests controller re-triggers after workflow completion
func TestControllerReTriggerAfterCompletion(t *testing.T) {
	logger, _ := zap.NewDevelopment()

	completedTenant := &tenant.Tenant{
		ID:       uuid.New(),
		TenantID: "test-tenant",
		Status:   tenant.StatusPlanning,
		WorkflowExecutionID: stringPtr("exec-completed-123"),
	}

	triggerCount := 0
	wfClient := &mockWorkflowClientForController{
		triggerWithSourceFunc: func(ctx context.Context, t *tenant.Tenant, action, source string) (string, error) {
			triggerCount++
			return "exec-new", nil
		},
		getStatusFunc: func(ctx context.Context, executionID string) (*workflow.ExecutionStatus, error) {
			// Return succeeded state - should trigger new execution
			return &workflow.ExecutionStatus{
				ExecutionID: executionID,
				State:       workflow.StateSucceeded,
			}, nil
		},
	}

	tenantRepo := &mockTenantRepository{
		getTenantFunc: func(ctx context.Context, tenantID string) (*tenant.Tenant, error) {
			return completedTenant, nil
		},
	}

	reconciler := &Reconciler{
		tenantRepo:     tenantRepo,
		workflowClient: wfClient,
		logger:         logger,
		ctx:            context.Background(),
	}

	err := reconciler.reconcile("test-tenant")
	if err != nil {
		t.Errorf("reconcile should not fail: %v", err)
	}

	// Should trigger new workflow after completion
	if triggerCount != 1 {
		t.Errorf("expected 1 trigger after completion, got %d triggers", triggerCount)
	}
}

// TestControllerReTriggerAfterFailure tests controller re-triggers after workflow failure
func TestControllerReTriggerAfterFailure(t *testing.T) {
	logger, _ := zap.NewDevelopment()

	failedTenant := &tenant.Tenant{
		ID:       uuid.New(),
		TenantID: "test-tenant",
		Status:   tenant.StatusPlanning,
		WorkflowExecutionID: stringPtr("exec-failed-123"),
	}

	triggerCount := 0
	wfClient := &mockWorkflowClientForController{
		triggerFunc: func(ctx context.Context, t *tenant.Tenant, action string) (string, error) {
			triggerCount++
			return "exec-retry", nil
		},
		getStatusFunc: func(ctx context.Context, executionID string) (*workflow.ExecutionStatus, error) {
			// Return failed state - should trigger new execution
			return &workflow.ExecutionStatus{
				ExecutionID: executionID,
				State:       workflow.StateFailed,
			}, nil
		},
	}

	tenantRepo := &mockTenantRepository{
		getTenantFunc: func(ctx context.Context, tenantID string) (*tenant.Tenant, error) {
			return failedTenant, nil
		},
	}

	reconciler := &Reconciler{
		tenantRepo:     tenantRepo,
		workflowClient: wfClient,
		logger:         logger,
		ctx:            context.Background(),
	}

	err := reconciler.reconcile("test-tenant")
	if err != nil {
		t.Errorf("reconcile should not fail: %v", err)
	}

	// Should trigger new workflow after failure
	if triggerCount != 1 {
		t.Errorf("expected 1 trigger after failure, got %d triggers", triggerCount)
	}
}

// TestControllerSkipsPendingWorkflow tests controller skips pending workflows
func TestControllerSkipsPendingWorkflow(t *testing.T) {
	logger, _ := zap.NewDevelopment()

	pendingTenant := &tenant.Tenant{
		ID:       uuid.New(),
		TenantID: "test-tenant",
		Status:   tenant.StatusProvisioning,
		WorkflowExecutionID: stringPtr("exec-pending-123"),
	}

	triggerCount := 0
	wfClient := &mockWorkflowClientForController{
		triggerFunc: func(ctx context.Context, t *tenant.Tenant, action string) (string, error) {
			triggerCount++
			return "exec-new", nil
		},
		getStatusFunc: func(ctx context.Context, executionID string) (*workflow.ExecutionStatus, error) {
			// Return pending state - should be skipped
			return &workflow.ExecutionStatus{
				ExecutionID: executionID,
				State:       workflow.StatePending,
			}, nil
		},
	}

	tenantRepo := &mockTenantRepository{
		getTenantFunc: func(ctx context.Context, tenantID string) (*tenant.Tenant, error) {
			return pendingTenant, nil
		},
	}

	reconciler := &Reconciler{
		tenantRepo:     tenantRepo,
		workflowClient: wfClient,
		logger:         logger,
		ctx:            context.Background(),
	}

	err := reconciler.reconcile("test-tenant")
	if err != nil {
		t.Errorf("reconcile should not fail: %v", err)
	}

	// Should not trigger for pending workflow
	if triggerCount != 0 {
		t.Errorf("expected no trigger for pending workflow, got %d triggers", triggerCount)
	}
}

// TestControllerTriggersWithControllerSource tests controller passes trigger_source=controller
func TestControllerTriggersWithControllerSource(t *testing.T) {
	logger, _ := zap.NewDevelopment()

	requestedTenant := &tenant.Tenant{
		ID:       uuid.New(),
		TenantID: "test-tenant",
		Status:   tenant.StatusRequested,
	}

	capturedSource := ""
	wfClient := &mockWorkflowClientForController{
		triggerWithSourceFunc: func(ctx context.Context, t *tenant.Tenant, action, source string) (string, error) {
			capturedSource = source
			return "exec-123", nil
		},
	}

	tenantRepo := &mockTenantRepository{
		getTenantFunc: func(ctx context.Context, tenantID string) (*tenant.Tenant, error) {
			return requestedTenant, nil
		},
	}

	reconciler := &Reconciler{
		tenantRepo:     tenantRepo,
		workflowClient: wfClient,
		logger:         logger,
		ctx:            context.Background(),
	}

	err := reconciler.reconcile("test-tenant")
	if err != nil {
		t.Errorf("reconcile should not fail: %v", err)
	}

	// Verify trigger source was "controller"
	if capturedSource != "controller" {
		t.Errorf("expected trigger_source 'controller', got '%s'", capturedSource)
	}
}

// TestControllerHandlesStatusCheckFailureGracefully tests controller continues if status check fails
func TestControllerHandlesStatusCheckFailureGracefully(t *testing.T) {
	logger, _ := zap.NewDevelopment()

	tenantWithExecution := &tenant.Tenant{
		ID:       uuid.New(),
		TenantID: "test-tenant",
		Status:   tenant.StatusPlanning,
		WorkflowExecutionID: stringPtr("exec-unknown-123"),
	}

	triggerCount := 0
	wfClient := &mockWorkflowClientForController{
		triggerFunc: func(ctx context.Context, t *tenant.Tenant, action string) (string, error) {
			triggerCount++
			return "exec-retry", nil
		},
		getStatusFunc: func(ctx context.Context, executionID string) (*workflow.ExecutionStatus, error) {
			// Simulate status check failure
			return nil, fmt.Errorf("status check failed")
		},
	}

	tenantRepo := &mockTenantRepository{
		getTenantFunc: func(ctx context.Context, tenantID string) (*tenant.Tenant, error) {
			return tenantWithExecution, nil
		},
	}

	reconciler := &Reconciler{
		tenantRepo:     tenantRepo,
		workflowClient: wfClient,
		logger:         logger,
		ctx:            context.Background(),
	}

	err := reconciler.reconcile("test-tenant")
	if err != nil {
		t.Errorf("reconcile should not fail on status check error: %v", err)
	}

	// Should retry triggering even if status check fails
	if triggerCount != 1 {
		t.Errorf("expected 1 trigger after status check failure, got %d triggers", triggerCount)
	}
}

// TestControllerNoExecutionIDTriggers tests controller triggers for tenants without execution ID
func TestControllerNoExecutionIDTriggers(t *testing.T) {
	logger, _ := zap.NewDevelopment()

	newTenant := &tenant.Tenant{
		ID:       uuid.New(),
		TenantID: "test-tenant",
		Status:   tenant.StatusRequested,
		// No execution ID
	}

	triggerCount := 0
	wfClient := &mockWorkflowClientForController{
		triggerFunc: func(ctx context.Context, t *tenant.Tenant, action string) (string, error) {
			triggerCount++
			return "exec-123", nil
		},
	}

	tenantRepo := &mockTenantRepository{
		getTenantFunc: func(ctx context.Context, tenantID string) (*tenant.Tenant, error) {
			return newTenant, nil
		},
	}

	reconciler := &Reconciler{
		tenantRepo:     tenantRepo,
		workflowClient: wfClient,
		logger:         logger,
		ctx:            context.Background(),
	}

	err := reconciler.reconcile("test-tenant")
	if err != nil {
		t.Errorf("reconcile should not fail: %v", err)
	}

	// Should trigger for new tenant
	if triggerCount != 1 {
		t.Errorf("expected 1 trigger for new tenant, got %d triggers", triggerCount)
	}
}

// Helper function
func stringPtr(s string) *string {
	return &s
}
